<?php

namespace AWSD\Database\Schema\Query;

use AWSD\Database\Schema\Query\Component\GroupByComponent;
use AWSD\Database\Schema\Query\Component\HavingComponent;
use AWSD\Database\Schema\Query\Component\JoinComponent;
use AWSD\Database\Schema\Query\Component\LimitComponent;
use AWSD\Database\Schema\Query\Component\OffsetComponent;
use AWSD\Database\Schema\Query\Component\OrderByComponent;
use AWSD\Database\Schema\Query\Component\WhereComponent;
use AWSD\Database\Schema\Query\Register\ExpressionsRegister;
use AWSD\Database\Schema\Query\Register\FieldsRegister;

/**
 * Class SelectQuery
 *
 * Generates a parameterized SQL SELECT query based on an entity class and modular components.
 *
 * Responsibilities:
 * - Supports dynamic selection of fields
 * - Composes SQL clauses via components:
 *   - JOIN, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET
 * - Accumulates bound parameters for safe PDO execution
 *
 * Example usage:
 * ```php
 * $query = (new SelectQuery($user))
 *     ->setFields(['id', 'email'])
 *     ->setWhere(['status' => 'active'])
 *     ->setOrderBy(['id' => 'DESC']);
 * $sql = $query->generateSql();
 * $params = $query->getParams();
 * ```
 *
 * @see AWSD\Database\Schema\Query\Component\WhereComponent
 * @see AWSD\Database\Schema\Query\AbstractQuery
 */
final class SelectQuery extends AbstractQuery implements QueryInterface
{

  private bool $isDistinct = false;

  /**
   * @var array<string, mixed> Parameters to be bound to the query (from WHERE clause and others).
   */
  private array $params;

  /**
   * @var FieldsRegister List of fields to be selected.
   * If empty, defaults to '*'.
   */
  private FieldsRegister $fieldsRegister;

  /**
   * @var ExpressionsRegister List of fields to be selected.
   * If empty, defaults to '*'.
   */
  private ExpressionsRegister $expressionsRegister;

  /**
   * @var array<string, string> SQL fragments for each query component (JOIN, WHERE, etc.).
   * Keys: JOIN, WHERE, GROUP_BY, HAVING, ORDER_BY, LIMIT, OFFSET.
   * Values: SQL snippets generated by their respective components.
   */
  private array $componentsSql;

  /**
   * Constructor
   *
   * Initializes the SelectQuery for a given entity.
   * No attributes are required for SELECT queries.
   *
   * @param class-string $entity The entity instance to select from.
   */
  public function __construct(string $entity)
  {
    parent::__construct($entity, []);
    $this->fieldsRegister = new FieldsRegister($this->tableName);
    $this->expressionsRegister =  new ExpressionsRegister($this->tableName);
    $this->params = [];
    $this->componentsSql = [
      "JOIN" => "",
      "WHERE" => "",
      "GROUP_BY" => "",
      "HAVING" => "",
      "ORDER_BY" => "",
      "LIMIT" => "",
      "OFFSET" => "",
    ];
  }

  /**
   * getQuerys and returns the full SQL SELECT statement.
   *
   * @return string The complete SELECT SQL statement.
   */
  public function generateSql(): string
  {
    return $this->getQuery($this->getFields(), $this->getComponentsSql());
  }

  /**
   * Returns the list of bound parameters accumulated during getQuery (typically from WHERE).
   *
   * @return array The associative array of PDO parameters.
   */
  public function getParams(): array
  {
    return $this->params;
  }

  /**
   * Defines the list of fields to select.
   * If omitted, defaults to `*`.
   *
   * @param array $fields The list of column names to select.
   * @return $this
   */
  public function setFields(array $fields): self
  {
    foreach ($fields as $key => $field) {
      $this->fieldsRegister->register($field);
    }
    return $this;
  }

  /**
   * Defines the list of fields to select.
   * If omitted, defaults to `*`.
   *
   * @param array $expressions The list of column names to select.
   * @return $this
   */
  public function setExpression(array $expressions): self
  {
    foreach ($expressions as $key => $expression) {
      $this->expressionsRegister->register($expression);
    }
    return $this;
  }

  /**
   * Adds one or more JOIN clauses to the query.
   *
   * @param array $joins The join definitions (format depends on JoinComponent).
   * @return $this
   */
  public function setJoin(array $joins): self
  {
    $joinComponent = new JoinComponent();
    foreach ($joins as $key => $join) {
      $joinComponent->add($join);
    }
    $this->componentsSql["JOIN"] = $joinComponent->getQuery();
    return $this;
  }

  /**
   * Adds a WHERE clause to the query.
   * Also collects parameters to be bound.
   *
   * @param array $conditions Associative array of conditions (field => value or structured format).
   * @return $this
   */
  public function setWhere(array $conditions): self
  {
    $whereComponent = new WhereComponent();
    $whereComponent->addMany($conditions);
    $this->componentsSql['WHERE'] = $whereComponent->getQuery();
    $this->params = array_merge($this->params, $whereComponent->getParams());
    return $this;
  }

  /**
   * Adds a GROUP BY clause to the query.
   *
   * @param array $groupBy List of column names to group by.
   * @return $this
   */
  public function setGroupBy(array $groupBy): self
  {
    $groupBy = new GroupByComponent($groupBy);
    $this->componentsSql["GROUP_BY"] = $groupBy->getQuery();
    return $this;
  }

  /**
   * Adds a HAVING clause to the query.
   *
   * @param array $having Associative array of conditions to apply after GROUP BY.
   * @return $this
   */
  public function setHaving(array $having): self
  {
    $this->componentsSql["HAVING"] = '';
    return $this;
  }

  /**
   * Adds an ORDER BY clause to the query.
   *
   * @param array $orderBy Associative array of field => direction ('ASC'|'DESC').
   * @return $this
   */
  public function setOrderBy(array $orderBy): self
  {
    $orderByComponent = new OrderByComponent();
    $orderByComponent->addMany($orderBy);
    $this->componentsSql["ORDER_BY"] = $orderByComponent->getQuery();
    $this->params = array_merge($this->params, $orderByComponent->getParams());
    return $this;
  }

  /**
   * Adds a LIMIT clause to the query.
   * Note: Uses LimitComponent (may be refactored).
   *
   * @param int $limit Format: 10
   * @return $this
   */
  public function setLimit(int $limit): self
  {
    $limitComponent = new LimitComponent($limit);
    $this->componentsSql["LIMIT"] = $limitComponent->getQuery();
    $this->params = array_merge($this->params, $limitComponent->getParams());
    return $this;
  }

  /**
   * Adds an OFFSET clause to the query.
   * Note: Uses OffsetComponent (may be refactored).
   *
   * @param int $offset Format: 20
   * @return $this
   */
  public function setOffset(int $offset): self
  {
    $offsetComponent = new OffsetComponent($offset);

    $this->componentsSql["OFFSET"] = $offsetComponent->getQuery();
    $this->params = array_merge($this->params, $offsetComponent->getParams());
    return $this;
  }

  public function setDistinct(bool $dictinct = true): self
  {
    $this->isDistinct = $dictinct;
    return $this;
  }


  /**
   * Assembles the final SQL SELECT string from fields and all added components.
   *
   * @param string $fields The selected fields string (comma-separated).
   * @param string $componentsSql The compiled SQL suffix (JOIN, WHERE, etc.).
   * @return string The final SELECT query string.
   */
  private function getQuery(string $fields, string $componentsSql): string
  {
    $table = $this->quote->quoteIdentifier($this->tableName);
    return <<<SQL
    SELECT $fields FROM $table $componentsSql;
    SQL;
  }

  /**
   * Returns the field list to select.
   * Defaults to `*` if not explicitly set.
   *
   * @return string Comma-separated list of fields.
   */
  private function getFields(): string
  {
    $fieldList = [];
    foreach ($this->fieldsRegister->getAll() as $key => $fieldDefinition) {
      $fieldList[] = $this->quote->quoteAlias("{$fieldDefinition->table}.{$fieldDefinition->column}", $fieldDefinition->alias);

      foreach ($this->expressionsRegister->getAll() as $key => $expressionDefinition) {
        $quotedAlias = $this->quote->quoteIdentifier($expressionDefinition->alias);
        $fieldList[] = "{$expressionDefinition->expression} AS $quotedAlias";
      }
    }
    $fieldList = empty($fieldList) ? '*' : implode(', ', $fieldList);
    return $this->isDistinct ? "DISTINCT $fieldList" : $fieldList;
  }

  /**
   * Compiles and filters all added SQL components (JOIN, WHERE, etc.) into a final clause string.
   *
   * @return string The concatenated SQL suffix.
   */
  private function getComponentsSql(): string
  {
    $componentsSqlFilter = array_filter($this->componentsSql, fn($v) => !empty($v));
    return implode(' ', array_filter($componentsSqlFilter));
  }
}
