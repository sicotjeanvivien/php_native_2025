<?php

namespace AWSD\Schema\Query;

use AWSD\Schema\Query\Component\GroupByComponent;
use AWSD\Schema\Query\Component\HavingComponent;
use AWSD\Schema\Query\Component\JoinComponent;
use AWSD\Schema\Query\Component\OrderByComponent;
use AWSD\Schema\Query\Component\WhereComponent;

/**
 * Class SelectQuery
 *
 * Builds a parameterized SQL SELECT query based on an entity class and dynamic query components.
 *
 * Responsibilities:
 * - Supports dynamic selection of fields
 * - Composes modular SQL clauses via components:
 *   - WHERE, JOIN, GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET
 * - Accumulates and exposes bound parameters for safe PDO execution
 *
 * Example usage:
 * ```php
 * $query = (new SelectQuery($user))
 *     ->setFields(['id', 'email'])
 *     ->setWhere(['status' => 'active'])
 *     ->setOrderBy(['id' => 'DESC']);
 * $sql = $query->generateSql();
 * $params = $query->getParams();
 * ```
 *
 * Note:
 * LIMIT and OFFSET currently use `OrderByComponent`, which may be temporary or subject to refactoring.
 *
 * @see AWSD\Schema\Query\Component\WhereComponent
 * @see AWSD\Schema\Query\AbstractQuery
 */
final class SelectQuery extends AbstractQuery implements QueryInterface
{

  /**
   * @var array<string, mixed> Parameters to be bound to the query (from WHERE clause and others).
   */
  private array $params;

  /**
   * @var array<int, string> List of fields to be selected.
   * If empty, defaults to '*'.
   */
  private array $fields;

  /**
   * @var array<string, string> SQL fragments for each query component (JOIN, WHERE, etc.).
   * Keys: JOIN, WHERE, GROUP_BY, HAVING, ORDER_BY, LIMIT, OFFSET.
   * Values: SQL snippets generated by their respective components.
   */
  private array $componentsSql;

  /**
   * Constructor
   *
   * Initializes the SelectQuery for a given entity.
   * No attributes are required for SELECT queries.
   *
   * @param object $entity The entity instance to select from.
   */
  public function __construct(object $entity)
  {
    parent::__construct($entity, []);
    $this->fields =  [];
    $this->params = [];
    $this->componentsSql = [
      "JOIN" => "",
      "WHERE" => "",
      "GROUP_BY" => "",
      "HAVING" => "",
      "ORDER_BY" => "",
      "LIMIT" => "",
      "OFFSET" => "",
    ];
  }

  /**
   * Builds and returns the full SQL SELECT statement.
   *
   * @return string The complete SELECT SQL statement.
   */
  public function generateSql(): string
  {
    return $this->getQuery($this->getFields(), $this->getcomponentsSql());
  }

  /**
   * Returns the list of bound parameters accumulated during build (typically from WHERE).
   *
   * @return array The associative array of PDO parameters.
   */
  public function getParams(): array
  {
    return $this->params;
  }

  /**
   * Defines the list of fields to select.
   * If omitted, defaults to `*`.
   *
   * @param array $fields The list of column names to select.
   * @return $this
   */
  public function setFields(array $fields): self
  {
    $this->fields = $fields;
    return $this;
  }

  /**
   * Adds one or more JOIN clauses to the query.
   *
   * @param array $joins The join definitions (format depends on JoinComponent).
   * @return $this
   */
  public function setJoin(array $joins): self
  {
    $this->componentsSql["JOIN"] = (new JoinComponent($joins))->build();
    return $this;
  }

  /**
   * Adds a WHERE clause to the query.
   * Also collects parameters to be bound.
   *
   * @param array $conditions Associative array of conditions (field => value or structured format).
   * @return $this
   */
  public function setWhere(array $conditions): self
  {
    $where = (new WhereComponent($conditions))->build();
    $this->componentsSql['WHERE'] = $where['sql'];
    $this->params = array_merge($this->params, $where['params']);
    return $this;
  }

  /**
   * Adds a GROUP BY clause to the query.
   *
   * @param array $groupBy List of column names to group by.
   * @return $this
   */
  public function setGroupBy(array $groupBy): self
  {
    $this->componentsSql["GROUP_BY"] = (new GroupByComponent($groupBy))->build();
    return $this;
  }

  /**
   * Adds a HAVING clause to the query.
   *
   * @param array $having Associative array of conditions to apply after GROUP BY.
   * @return $this
   */
  public function setHaving(array $having): self
  {
    $this->componentsSql["HAVING"] = (new HavingComponent($having))->build();
    return $this;
  }

  /**
   * Adds an ORDER BY clause to the query.
   *
   * @param array $orderBy Associative array of field => direction ('ASC'|'DESC').
   * @return $this
   */
  public function setOrderBy(array $orderBy): self
  {
    $this->componentsSql["ORDER_BY"] = (new OrderByComponent($orderBy))->build();
    return $this;
  }

  /**
   * Adds a LIMIT clause to the query.
   * Note: Uses OrderByComponent (may be refactored).
   *
   * @param array $limit Format: ['LIMIT' => 10]
   * @return $this
   */
  public function setLimit(array $limit): self
  {
    $this->componentsSql["LIMIT"] = (new OrderByComponent($limit))->build();
    return $this;
  }

  /**
   * Adds an OFFSET clause to the query.
   * Note: Uses OrderByComponent (may be refactored).
   *
   * @param array $offset Format: ['OFFSET' => 20]
   * @return $this
   */
  public function setOffset(array $offset): self
  {
    $this->componentsSql["OFFSET"] = (new OrderByComponent($offset))->build();
    return $this;
  }

  /**
   * Assembles the final SQL SELECT string from fields and all added components.
   *
   * @param string $fields The selected fields string (comma-separated).
   * @param string $componentsSql The compiled SQL suffix (JOIN, WHERE, etc.).
   * @return string The final SELECT query string.
   */
  private function getQuery(string $fields, string $componentsSql): string
  {
    return <<<SQL
    SELECT $fields FROM $this->tableName $componentsSql;
    SQL;
  }

  /**
   * Returns the field list to select.
   * Defaults to `*` if not explicitly set.
   *
   * @return string Comma-separated list of fields.
   */
  private function getFields(): string
  {
    return  empty($this->fields) ? '*' : implode(', ', $this->fields);
  }

  /**
   * Compiles and filters all added SQL components (JOIN, WHERE, etc.) into a final clause string.
   *
   * @return string The concatenated SQL suffix.
   */
  private function getcomponentsSql(): string
  {
    $componentsSqlFilter = array_filter($this->componentsSql, fn($v) => !empty($v));
    return implode(' ', array_filter($componentsSqlFilter));
  }
}
